# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

```bash
# Format Go code (always run after modifying .go files)
go fmt

# Run tests (always run after finishing tasks involving .go files)
go test ./...

# Build and test locally
make local

# Run linting and tests
make test

# Build the project
make build
```

## Architecture Overview

awstools is a CLI application built with Go and the Cobra framework for AWS resource management and analysis. The application focuses on complex AWS operations that require multiple CLI calls.

### Core Structure

- **main.go**: Entry point that delegates to cmd package
- **cmd/**: Contains all CLI command definitions using Cobra framework
  - **root.go**: Base command configuration with global flags and settings
  - Individual command files for each AWS service (iam.go, vpc.go, s3.go, etc.)
- **helpers/**: Core business logic and AWS SDK interactions
  - Service-specific helpers (ec2.go, s3.go, iam.go, etc.)
  - **utils.go**: Common utility functions
- **config/**: Configuration management using Viper
  - **config.go**: Global configuration structure and methods
  - **awsconfig.go**: AWS-specific configuration handling

### Key Design Patterns

1. **Command Pattern**: Each AWS service has its own command file in cmd/ with corresponding helper functions
2. **Configuration Management**: Uses Viper for config files (.awstools.yaml) and environment variables
3. **Output Flexibility**: Supports multiple output formats (JSON, CSV, table, HTML, dot, drawio, mermaid) via github.com/ArjenSchwarz/go-output
4. **AWS SDK v2**: Uses aws-sdk-go-v2 for all AWS interactions
5. **Naming Resolution**: Optional naming files for human-readable resource names

### AWS Services Integration

The application integrates with these AWS services:
- IAM (users, roles, policies)
- VPC (routes, peering, security groups)
- CloudFormation (stacks, resources)
- Organizations (structure, accounts)
- SSO (permission sets, accounts)
- S3 (bucket listing, versioning)
- App Mesh (meshes, nodes, routes)
- Transit Gateway (routes, attachments)
- EC2 (instances, ENIs)

### Configuration System

- Config files: .awstools.yaml (local directory or home directory)
- Supports YAML, JSON, and TOML formats
- AWS credentials from standard locations (env vars, ~/.aws/credentials, IAM roles)
- Profile and region overrides via flags
- Naming files for resource name resolution

### Output System

All commands support consistent output options:
- Multiple formats: json (default), csv, table, html, dot, drawio, mermaid
- File output with append capability for multi-account data collection
- Verbose mode for additional details
- Emoji support for enhanced visual output

## Error Handling Guidelines

- **Never use panic()** for expected errors (API failures, invalid input, etc.)
- **Always return errors** from functions that can fail
- **Handle AWS SDK errors gracefully** with appropriate error messages
- **Use context.TODO()** for AWS SDK calls (following existing patterns)

## Code Quality Standards

- **Follow existing patterns** in the codebase for consistency
- **Use existing helper functions** rather than duplicating logic
- **Maintain backward compatibility** for CLI commands and output formats
- **Add tests** for new functionality when possible

## Performance Considerations

- **AWS API calls are expensive** - batch operations when possible
- **Memory usage matters** - avoid materializing large datasets unnecessarily
- **Use existing caching patterns** (like ENILookupCache) for repeated lookups
- **Consider AWS service limits** when designing features

## Testing Requirements

- **Always run `go fmt`** after modifying .go files
- **Always run `go test ./...`** after finishing tasks involving .go files
- **Run `make test`** for full linting and testing
- **Use `make go-functions`** to explore the codebase when needed
- **Test with real AWS resources** when possible (the tool is designed for production use)

## Agent Guidelines

1. **Use available tools**: Leverage Makefile targets (`make test`, `make build`, `make go-functions`)
2. **Prefer simple solutions** over complex ones
3. **Verify all changes** before stating a task is completed
4. **Don't add attribution** like "Generated by Claude" to commits or pull requests
5. **Follow the existing architecture** - don't introduce new patterns without justification
6. **Consider the end user** - this tool is used by AWS practitioners for real infrastructure analysis